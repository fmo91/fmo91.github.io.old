{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/0001-single-source-of-truth/","result":{"data":{"site":{"siteMetadata":{"title":"Swiffer","social":[{"name":"twitter","url":"https://twitter.com/fmo_91"},{"name":"github","url":"https://github.com/fmo91"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"0d6d91e4-12f0-5594-8b9f-37f1ec4d5020","excerpt":"I've been an iOS developer for almost five years. And working as a software engineer, you may know, is something frustrating. \nSure, it'sâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"A single source of truth\",\n  \"date\": \"2019-10-26T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I\\u2019ve been an iOS developer for almost five years. And working as a software engineer, you may know, is something frustrating.\\nSure, it\\u2019s fulfulling, it\\u2019s a creative activity, I know, but it\\u2019s also frustrating. One thing I realised with the time\\nis that your taste evolves faster than your ability. \"), mdx(\"p\", null, \"In my first projects, I followed the only technique I knew: programming imperatively. And it worked. Screens appeared in my\\napp, with the controls I programmed, and I felt better at the time.\"), mdx(\"p\", null, \"The main characteristic that differentiates a junior developer from a senior one is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"understanding of tradeoffs\"), \". A senior developer can create code that is scalable over time, and does that when required. He almost always chooses the approach that is complex enough to get the work done, but creating the least amount of accidental complexity in the process.\"), mdx(\"p\", null, \"This introduction may seem a bit longer than needed, but it\\u2019s important to take this into account, because there are a lot of tools to solve each problem, and this one is not a exception. Today, I\\u2019ll write about the most important issue a UI developer face every day in my opinion: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"State management\"), \".\"), mdx(\"h2\", {\n    \"id\": \"our-problem\"\n  }, \"Our problem\"), mdx(\"p\", null, \"Let\\u2019s work with an example. We are working on a calculator that operates on two numbers. The requirements for our simple screen would be:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"There must be two text fields, so the user can introduce the arguments.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"There must be a third text field, in which the user can select the operation to be performed.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"There must be a label where the result will appear.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"There must be no button. The entire UI should be refreshed on any change that may occur.\")), mdx(\"h2\", {\n    \"id\": \"what-i-used-to-do\"\n  }, \"What I used to do\"), mdx(\"p\", null, \"So here is what I would have done when I started as a developer.\"), mdx(\"p\", null, \"First, I would have created the outlets for the views (I\\u2019ll not specify how the storyboard is done, to be more concise):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"final class ViewController: UIViewController\\n    // MARK: - Views -\\n    @IBOutlet private weak var firstNumberTextField: UITextField!\\n    @IBOutlet private weak var secondNumberTextField: UITextField!\\n    @IBOutlet private weak var operationTextField: UITextField!\\n    @IBOutlet private weak var resultLabel: UILabel!\\n\\n    // ...\\n}\\n\")), mdx(\"p\", null, \"Then, I\\u2019d have configured the event handlers for my views, and an enum that will be helpful for to describe the operations:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"final class ViewController: UIViewController {\\n    // ...\\n\\n    // MARK: - Life Cycle -\\n    override func viewDidLoad() {\\n        super.viewDidLoad()\\n    \\n        firstNumberTextField.addTarget(self,\\n            action: #selector(firstNumberTextFieldChanged),\\n            for: .editingChanged\\n        )\\n        \\n        secondNumberTextField.addTarget(self,\\n            action: #selector(secondNumberTextFieldChanged),\\n            for: .editingChanged\\n        )\\n        \\n        operationPickerView = UIPickerView()\\n        operationPickerView.delegate = self\\n        operationPickerView.dataSource = self\\n        operationTextField.inputView = operationPickerView\\n    }\\n\\n    // MARK: - Actions -\\n    @objc private func firstNumberTextFieldChanged() {\\n        calculateResult()\\n    }\\n    \\n    @objc private func secondNumberTextFieldChanged() {\\n        calculateResult()\\n    }\\n \\n}\\n\\n// MARK: - UIPickerViewDelegate, UIPickerViewDataSource -\\nextension ViewController: UIPickerViewDelegate, UIPickerViewDataSource {\\n    func numberOfComponents(in pickerView: UIPickerView) -> Int {\\n        return 1\\n    }\\n    \\n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {\\n        return MathOperation.allCases.count\\n    }\\n    \\n    func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -> String? {\\n        return MathOperation.allCases[row].rawValue\\n    }\\n    \\n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {\\n        operationTextField.text = MathOperation.allCases[row].rawValue\\n        selectedOperation = MathOperation.allCases[row]\\n        calculateResult()\\n    }\\n}\\n\\nenum MathOperation: String, CaseIterable {\\n    enum Error: Swift.Error {\\n        case divideByZero\\n    }\\n    \\n    case  divide    = \\\"/\\\"\\n        , sum       = \\\"+\\\"\\n        , sub       = \\\"-\\\"\\n        , multiply  = \\\"*\\\"\\n    \\n    func operate(on firstNumber: Int, and secondNumber: Int) throws -> Double {\\n        switch self {\\n        case .divide:\\n            guard secondNumber != 0 else {\\n                throw Error.divideByZero\\n            }\\n            return Double(firstNumber / secondNumber)\\n        case .sum:\\n            return Double(firstNumber + secondNumber)\\n        case .sub:\\n            return Double(firstNumber - secondNumber)\\n        case .multiply:\\n            return Double(firstNumber * secondNumber)\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"And finally, a method that would have refreshed the views accordingly:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"final class ViewController: UIViewController {\\n    // ...\\n\\n    // MARK: - Helper methods -\\n    private func calculateResult() {\\n        guard let firstNumber = Int(firstNumberTextField.text ?? \\\"\\\")\\n            , let secondNumber = Int(secondNumberTextField.text ?? \\\"\\\")\\n            , let selectedOperation = self.selectedOperation\\n        else {\\n            return\\n        }\\n        \\n        do {\\n            let result = try selectedOperation.operate(on: firstNumber, and: secondNumber)\\n            resultLabel.text = result.description\\n        } catch let error {\\n            switch error {\\n            case MathOperation.Error.divideByZero:\\n                resultLabel.text = \\\"Cannot divide by zero\\\"\\n            default:\\n                resultLabel.text = \\\"Something went wrong...\\\"\\n            }\\n        }\\n    }\\n\\n    // ...\\n}\\n\")), mdx(\"p\", null, \"This approach works great for basic tasks. And I insist with this, because there is nothing wrong with it in my opinion. However, if we know that the screen will be more complicated, or if there are more requirements that we haven\\u2019t coded yet, we can make some changes to it.\"), mdx(\"h2\", {\n    \"id\": \"the-rule\"\n  }, \"The rule\"), mdx(\"p\", null, \"I have a main rule when it comes to UI software development: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"There should be a single source of truth, so state is always consistent.\")), mdx(\"p\", null, \"State is a bomb of complexity, that will explode on your face if you aren\\u2019t careful enough. So, as state is a bomb, and we have to be careful of it, it would be better if we isolate it, so the rest of our code will be safe.\"), mdx(\"p\", null, \"We can create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \". Or name it as you want. The purpose of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \" is to store the state for our view, and encapsulate the logic of how to manipulate it. Our View won\\u2019t know how to operate on the operands anymore, nor know what is an operand, or which is the current operand. In our example, our view will:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Handle the user events, and notify the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ViewModel\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Get data from the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ViewModel\"), \" and update accordingly whenever the data changes.\")), mdx(\"p\", null, \"And the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \" will be responsible for:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Receive events from the view.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Expose data to the view and notify whenever the data changes.\")), mdx(\"p\", null, \"This approach is a bit more complex, because we need to maintain two classes instead of one, but it has other benefits. We splitted the responsibilities, and we know that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \" will \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"always\"), \" have the current state. There won\\u2019t be duplicated states, or inconsistent states on our view.\"), mdx(\"p\", null, \"We\\u2019ll need a way to notify the view when the data changes in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \". We can use delegation, or configure a closure so we can execute it from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \" when the data changes, but it\\u2019s better to use a specialized tool for this. Some people use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RxSwift\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RxCocoa\"), \", and I\\u2019m also a great enthusiast of these tools. However, Apple listened us and created a library that is included in the iOS SDK and does that for us: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Combine\"), \". So we\\u2019ll use it on our example\"), mdx(\"p\", null, \"In practice, this will be our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"final class ViewModel {\\n    // 1.\\n    @Published var operation: MathOperation?\\n    @Published var operationText: String?\\n    @Published var firstNumberText: String?\\n    @Published var secondNumberText: String?\\n    @Published var result: String?\\n    \\n    @Published private var firstNumber: Int?\\n    @Published private var secondNumber: Int?\\n    \\n    // 2.\\n    private var cancellables: [AnyCancellable] = []\\n    \\n    init() {\\n        // 3.\\n        $firstNumberText\\n            .compactMap({ Int($0 ?? \\\"\\\") })\\n            .assign(to: \\\\.firstNumber, on: self)\\n            .add(to: &cancellables)\\n        \\n        $secondNumberText\\n            .compactMap({ Int($0 ?? \\\"\\\") })\\n            .assign(to: \\\\.secondNumber, on: self)\\n            .add(to: &cancellables)\\n        \\n        $operation\\n            .compactMap({ $0?.rawValue })\\n            .assign(to: \\\\.operationText, on: self)\\n            .add(to: &cancellables)\\n        \\n        // 4.\\n        Publishers.CombineLatest3($firstNumber, $secondNumber, $operation)\\n            .tryMap { (firstNumber: Int?, secondNumber: Int?, operation: MathOperation?) throws -> String? in\\n                guard\\n                    let firstNumber = firstNumber,\\n                    let secondNumber = secondNumber,\\n                    let operation = operation\\n                else {\\n                    return nil\\n                }\\n                let result = try operation.operate(on: firstNumber, and: secondNumber)\\n                return result.description\\n            }\\n            .catch { (error: Error) -> Just<String?> in\\n                switch error {\\n                case MathOperation.Error.divideByZero:\\n                    return Just(\\\"Cannot divide by zero\\\")\\n                default:\\n                    return Just(\\\"Something went wrong...\\\")\\n                }\\n            }\\n            .assign(to: \\\\.result, on: self)\\n            .add(to: &cancellables)\\n    }\\n}\\n\")), mdx(\"p\", null, \"So, what\\u2019s happening here? Let\\u2019s go through it:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"In \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Combine\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@Published\"), \" variables are variables that are like any other variable, but they have a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"projectedValue\"), \" (the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$\"), \" prefix) that returns us the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Publisher\"), \" associated to it. And by using a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Published\"), \" we can operate on the changes the value can have over time. In our \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ViewModel\"), \" we have \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"input\"), \" variables (the ones that our View Controller sets), and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"output\"), \" variables (the variables our View Controller listens to).\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When we listen to a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Publisher\"), \", that \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"subscription\"), \" needs to be managed in terms of memory usage. That\\u2019s what our array of AnyCancellables does. Apart from that, we can use this extension to make our code more elegant:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"extension AnyCancellable {\\n    func add(to cancellables: inout [AnyCancellable]) {\\n        cancellables.append(self)\\n    }\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"These are the listeners we can configure so our code is reactive.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Whenever the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"firstNumberText\"), \" value changes, it\\u2019s converted into a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Int\"), \", and finally it\\u2019s value is assigned to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"firstNumber\"), \". We do the same with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"secondNumberText\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"secondNumber\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Something similar is used to transform \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"operation\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"operationText\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"As we are making subscriptions, we need to manage the memory usage here appending them to our array of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AnyCancellable\"), \" objects.\")), mdx(\"ol\", {\n    \"start\": 4\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"This is basically what \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"calculateResult\"), \" did in our previous example. We execute this whenever \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"firstNumber\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"secondNumber\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"operation\"), \" change. And finally we assign the value to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"result\"), \".\")), mdx(\"p\", null, \"On the other side, we need to update ViewController, the code is below, but the important thing to keep in mind here is that now our VIewController just updates values in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \" and listens to changes on it. Nothing else.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"final class ViewController: UIViewController {\\n    \\n    // MARK: - Views -\\n    @IBOutlet private weak var firstNumberTextField: UITextField!\\n    @IBOutlet private weak var secondNumberTextField: UITextField!\\n    @IBOutlet private weak var operationTextField: UITextField!\\n    @IBOutlet private weak var resultLabel: UILabel!\\n    \\n    private var operationPickerView: UIPickerView!\\n    \\n    // MARK: - Attributes -\\n    private let viewModel = ViewModel()\\n    private var cancellables: [AnyCancellable] = []\\n\\n    // MARK: - Life Cycle -\\n    override func viewDidLoad() {\\n        super.viewDidLoad()\\n    \\n        firstNumberTextField.addTarget(self,\\n            action: #selector(firstNumberTextFieldChanged),\\n            for: .editingChanged\\n        )\\n        \\n        secondNumberTextField.addTarget(self,\\n            action: #selector(secondNumberTextFieldChanged),\\n            for: .editingChanged\\n        )\\n        \\n        operationPickerView = UIPickerView()\\n        operationPickerView.delegate = self\\n        operationPickerView.dataSource = self\\n        operationTextField.inputView = operationPickerView\\n        \\n        bindToViewModel()\\n    }\\n\\n    // MARK: - Private methods -\\n    private func bindToViewModel() {\\n        viewModel.$operationText\\n            .assign(to: \\\\.text, on: operationTextField)\\n            .add(to: &cancellables)\\n        \\n        viewModel.$result\\n            .assign(to: \\\\.text, on: resultLabel)\\n            .add(to: &cancellables)\\n    }\\n    \\n    // MARK: - Actions -\\n    @objc private func firstNumberTextFieldChanged() {\\n        viewModel.firstNumberText = firstNumberTextField.text\\n    }\\n    \\n    @objc private func secondNumberTextFieldChanged() {\\n        viewModel.secondNumberText = secondNumberTextField.text\\n    }\\n    \\n}\\n\\nextension ViewController: UIPickerViewDelegate, UIPickerViewDataSource {\\n    func numberOfComponents(in pickerView: UIPickerView) -> Int {\\n        return 1\\n    }\\n    \\n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {\\n        return MathOperation.allCases.count\\n    }\\n    \\n    func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -> String? {\\n        return MathOperation.allCases[row].rawValue\\n    }\\n    \\n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {\\n        viewModel.operation = MathOperation.allCases[row]\\n    }\\n}\\n\")), mdx(\"p\", null, \"Much simpler.\"), mdx(\"h2\", {\n    \"id\": \"a-bright-future-in-the-horizon\"\n  }, \"A bright future in the horizon\"), mdx(\"p\", null, \"As you can guess. the above code is elegant and scalable. But it still looks unnatural. These are not how UIKit was build to be used. UIKit is imperative. And even the documentation Apple gives to us encourages us to work imperatively. This is embedded in the DNA of the framework.\"), mdx(\"p\", null, \"But something is changing. The reactive/declarative approach for UI development and state management has gained great adoption during the last five years or so, mainly since React gained popularity and became the default way to build UIs in the web.\"), mdx(\"p\", null, \"Apple also listened to this revolution taking place, and came out with a new shiny framework named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SwiftUI\"), \". In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SwiftUI\"), \" we declare our state, and the view that is build using that state. Whenever the state changes, the view is configured again. Sounds familiar? It\\u2019s exactly the principle our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \"-based solution was built based on.\"), mdx(\"p\", null, \"Even when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SwiftUI\"), \" is in its infancy, it\\u2019s a great tool we should keep an eye on it.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/0001-single-source-of-truth/","title":"A single source of truth","tags":[],"keywords":[],"date":"October 26, 2019"},"previous":null,"next":null},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"0d6d91e4-12f0-5594-8b9f-37f1ec4d5020"}}}