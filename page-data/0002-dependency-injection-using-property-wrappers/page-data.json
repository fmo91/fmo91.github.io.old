{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/0002-dependency-injection-using-property-wrappers/","result":{"data":{"site":{"siteMetadata":{"title":"fmo91","social":[{"name":"twitter","url":"https://twitter.com/fmo_91"},{"name":"github","url":"https://github.com/fmo91"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"0eeeceff-91ee-5b9d-88b3-e537a600a404","excerpt":"TL;DR  ::  Here is the gist. Dependency injection is critical to get a good-quality codebase. As misterious as it can sound, dependencyâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Simple Dependency Injection using @propertyWrapper\",\n  \"date\": \"2019-11-02T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TL;DR\"), \" :: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://gist.github.com/fmo91/2d359f82569dda69002784a49486b3c8\"\n  }), \"Here is the gist.\"))), mdx(\"p\", null, \"Dependency injection is critical to get a good-quality codebase. As misterious as it can sound, dependency injection is central in software architecture.\"), mdx(\"p\", null, \"But, what is it exactly? Well, let\\u2019s explain it through an example. Let\\u2019s suppose we want to design a groceries store calculator. We want to sum all the products\\u2019 prices and then calculate the taxes to the sub-total. We\\u2019ll start with a module: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProductsCalculator\"), \", and a struct called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Product\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"struct Product {\\n    // ...\\n    let price: Double\\n}\\n\\nclass ProductsCalculator {\\n    private var products: [Product] = []\\n\\n    func add(product: Product) {\\n        products.append(product)\\n    }\\n\\n    func calculateTotal() -> Double {\\n        let subtotal = products.map({ $0.price }).reduce(0, +)\\n        return applyTaxes(to: subtotal)\\n    }\\n\\n    private func applyTaxes(to subtotal: Double) -> Double {\\n        // Some weird taxes logic \\uD83D\\uDE28\\n        subtotal * 1.21\\n    }\\n}\\n\")), mdx(\"p\", null, \"This can work for a simple use case. But real world scenarios are hardly ever that simple. Out there, in the real world, we will find really strange logics that will change over time, and we need to be prepared for them. And our most important tool for this, is a good software architecture. To get a good architecture, we will need to decouple the code a bit by splitting it into modules. And a good option here is to create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TaxesCalculator\"), \" object that can calculate the taxes to be applied. For example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"class TaxesCalculator {\\n    func applyTaxes(to subtotal: Double) -> Double {\\n        // Some weird taxes logic \\uD83D\\uDE28\\n        subtotal * 1.21\\n    }\\n}\\n\\nclass ProductsCalculator {\\n    private let taxesCalculator = TaxesCalculator()\\n\\n    // ...\\n\\n    func calculateTotal() -> Double {\\n        let subtotal = products.map({ $0.price }).reduce(0, +)\\n        return taxesCalculator.applyTaxes(to: subtotal)\\n    }\\n}\\n\")), mdx(\"p\", null, \"This way, we could change the code in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TaxesCalculator\"), \" without modifying \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProductsCalculator\"), \". However, we can improve this design a lot. In first place, a good practice is to code against an interface and never against a concrete implementation. To apply this gold principle here, we would need to do something like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"protocol TaxesCalculatorType {\\n    func applyTaxes(to subtotal: Double) -> Double\\n}\\n\\nclass TaxesCalculatorA: TaxesCalculatorType {\\n    func applyTaxes(to subtotal: Double) -> Double {\\n        // Some weird taxes logic \\uD83D\\uDE28\\n        subtotal * 1.21\\n    }\\n}\\n\\nclass TaxesCalculatorB: TaxesCalculatorType {\\n    func applyTaxes(to subtotal: Double) -> Double {\\n        // Some weird taxes logic \\uD83D\\uDE28\\n        subtotal * 1.41\\n    }\\n}\\n\\nclass ProductsCalculator {\\n    private let taxesCalculator: TaxesCalculatorType = TaxesCalculatorA()\\n\\n    // ...\\n\\n    func calculateTotal() -> Double {\\n        let subtotal = products.map({ $0.price }).reduce(0, +)\\n        return taxesCalculator.applyTaxes(to: subtotal)\\n    }\\n}\\n\")), mdx(\"p\", null, \"This way, we can vary the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TaxesCalculatorType\"), \" we are using without affecting the internal logic in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProductsCalculator\"), \". Each module knows only what is needs to know.\"), mdx(\"p\", null, \"This code still has an important failure in its design\\u2026 We are still instantiating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TaxesCalculatorType\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProductsCalculator\"), \" class, so it still has a strong dependency on the concrete implementation. And now is when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dependency Injection\"), \" comes into the play.\"), mdx(\"p\", null, \"We will need to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inject\"), \" the concrete \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TaxesCalculatorType\"), \" object in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ProductsCalculator\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"class ProductsCalculator {\\n    private let taxesCalculator: TaxesCalculatorType\\n\\n    // ...\\n\\n    init(taxesCalculator: TaxesCalculatorType) {\\n        self.taxesCalculator = taxesCalculator\\n    }\\n\\n    func calculateTotal() -> Double {\\n        let subtotal = products.map({ $0.price }).reduce(0, +)\\n        return taxesCalculator.applyTaxes(to: subtotal)\\n    }\\n}\\n\")), mdx(\"p\", null, \"By injecting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TaxesCalculatorType\"), \" in the constructor, we don\\u2019t have a dependency on the concrete implementation anymore.\"), mdx(\"p\", null, \"To generalize, when you have two modules A and B, A has a dependency on B if it calls a method from B, or has a reference for B, or knows something about B. Then, we have two possiblities, A can either know exactly how to create B, and how to use it, or we can \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inject\"), \" B into A. That\\u2019s what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dependency injection\"), \" (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DI\"), \") is about: Don\\u2019t letting a module know all about its dependencies, but giving it its dependencies from the outside. That way, we can give it different objects depedending on the context.\"), mdx(\"h2\", {\n    \"id\": \"different-ways-to-inject-a-dependency\"\n  }, \"Different ways to inject a dependency.\"), mdx(\"p\", null, \"The four most common ways to inject a dependency are:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Using a method/property\"), \": We pass the concrete implementation by calling a method or setting a property in the class. For example:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"class ProductsCalculator {\\n    // ...\\n    func calculateTotal(using taxesCalculator: TaxesCalculatorType) -> Double {\\n        let subtotal = products.map({ $0.price }).reduce(0, +)\\n        return taxesCalculator.applyTaxes(to: subtotal)\\n    }\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Injecting in the constructor\"), \": We inject the dependency using the constructor, as seen in the first example.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Using a DI Container\"), \": This is more popular on other stacks (like Java, for example). We use a class called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Container\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"register\"), \" the dependencies at the beginning of the program, and then from the rest of the code we ask the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Container\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"resolve\"), \" which class should we use there.\")), mdx(\"h2\", {\n    \"id\": \"property-wrappers\"\n  }, \"Property Wrappers\"), mdx(\"p\", null, \"Enough with Dependency Injection. Let\\u2019s talk about the other important part of this article: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Property Wrappers\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Property Wrappers\"), \" are a new addition in Swift 5. They let us \\u201Cdelegate\\u201D the access of a property to a struct that is annotated with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@propertyWrapper\"), \". Let\\u2019s explain it with an example before jumping into dependency injection again: We want to have an array that is always sorted by a specific criteria.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"// @propertyWrapper annotation makes this\\n// struct a property wrapper.\\n// It will be a generic struct because we will make\\n// it work with any kind of value type.\\n@propertyWrapper\\nstruct Sorted<T> {\\n    // Internally, we will store the actual value of\\n    // the array in this property\\n    private var value: [T]\\n\\n    // As we want to sort the array each time we introduce a new\\n    // value in it, we need to store the sort function.\\n    private let sortFunction: (T, T) -> Bool\\n\\n    // The only requisite for a struct to be a propertyWrapper is this\\n    // computed property.\\n    // The wrappedValue property is accesible from the outside.\\n    // Each time we want to get the property value, the getter will\\n    // be called, and each time we want to set a value for this\\n    // property, its setter will be called.\\n    var wrappedValue: [T] {\\n        get { return value }\\n        set { value = newValue.sorted(by: sortFunction) }\\n    }\\n    \\n    // In the init, we have the special argument `wrappedValue`,\\n    // that represents the initial assigned value\\n    // and we will also send a sortFunction that will be used for\\n    // sorting the array each time we add a new value to it.\\n    init(wrappedValue value: [T], by sortFunction: @escaping (T, T) -> Bool) {\\n        self.sortFunction = sortFunction\\n        self.value = value.sorted(by: sortFunction)\\n    }\\n}\\n\")), mdx(\"p\", null, \"So let\\u2019s see how we can use it:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"struct Person {\\n    let name: String\\n}\\n\\nstruct People {\\n    // This empty array will be the wrappedValue in the init.\\n    @Sorted(by: { $0.name < $1.name }) var items: [Person] = [] \\n}\\n\\nvar people = People()\\npeople.append(Person(name: \\\"John\\\"))\\npeople.append(Person(name: \\\"Harry\\\"))\\npeople.append(Person(name: \\\"Allan\\\"))\\nprint(people.items.map({ $0.name })) // [\\\"Allan\\\", \\\"Harry\\\", \\\"John\\\"]\\n\")), mdx(\"p\", null, \"Not that hard, huh? Another thing I haven\\u2019t said in the example is that all the properties that are annotated by a property wrapper need to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \" isn\\u2019t allowed to be used with property wrappers.\"), mdx(\"h2\", {\n    \"id\": \"so-what\"\n  }, \"So, what?\"), mdx(\"p\", null, \"How are property wrappers related to Dependency Injection? They seem to be cool stuff but not related in any way so far. Yes, that can seem to be the case, but we can use property wrappers to inject dependencies from a DI Container.\"), mdx(\"p\", null, \"Let\\u2019s see how this could work.\"), mdx(\"p\", null, \"We will start by creating a NameContainer for the dependencies:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"// We will create an enum as a namespace\\nenum Dependencies {\\n    // The same pattern that NotificationCenter's Name struct\\n    // follows.\\n    struct Name: Equatable {\\n        let rawValue: String\\n        static let `default` = Name(rawValue: \\\"__default__\\\")\\n        static func == (lhs: Name, rhs: Name) -> Bool { lhs.rawValue == rhs.rawValue }   \\n    }\\n\\n    // The actual DI Container\\n    final class Container {\\n        // An array with the dependencies and the keys for them.\\n        private var dependencies: [(key: Dependencies.Name, value: Any)] = []\\n        \\n        // To use like a singleton.\\n        static let `default` = Container()\\n    }\\n}\\n\")), mdx(\"p\", null, \"We need two more functions in the container: \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"register\"), \": Adds a new entry for the dependencies registry. Optionally namespaced.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"resolve\"), \": It will return the needed dependency for the requested type. It can also work for namespaced dependencies.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"enum Dependencies {\\n    // ...\\n    final class Container {\\n        // ...\\n        func register(_ dependency: Any, for key: Dependencies.Name = .default) {\\n            dependencies.append((key: key, value: dependency))\\n        }\\n        \\n        func resolve<T>(_ key: Dependencies.Name = .default) -> T {\\n            return (dependencies\\n                .filter { (dependencyTuple) -> Bool in\\n                    return dependencyTuple.key == key\\n                        && dependencyTuple.value is T\\n                }\\n                .first)?.value as! T\\n        }   \\n    }\\n    // ...\\n}\\n\")), mdx(\"p\", null, \"Finally we need a property wrapper that can inject a dependency from the container in a property from an unrelated class. This property wrapper needs an optional argument for the dependency key and another optional argument for the DI container (it will default to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"default\"), \" singleton container).\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"enum Dependencies {\\n    // ...\\n    @propertyWrapper\\n    struct Inject<T> {\\n        private let dependencyName: Name\\n        private let container: Container\\n        var wrappedValue: T {\\n            get { container.resolve(dependencyName) }\\n        }\\n        init(_ dependencyName: Name = .default, on container: Container = .default) {\\n            self.dependencyName = dependencyName\\n            self.container = container\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Simple, right?\"), mdx(\"p\", null, \"Let\\u2019s see how we can use this utility:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"// We create a protocol for formatting a name\\nprotocol NameFormatterType {\\n    func format(name: String) -> String\\n}\\n\\n// A concrete implementation adds a prefix \\\"Sir\\\" to the given name.\\nstruct SirFormatter: NameFormatterType {\\n    func format(name: String) -> String {\\n        \\\"Sir \\\\(name)\\\"\\n    }\\n}\\n\\n// We will register that implementation\\nDependencies.Container.default.register(SirFormatter())\\n\\n// Apart from that, we have a Person struct.\\nstruct Person {\\n    // We INJECT the NameFormatterType dependency using our handy annotation.\\n    @Dependencies.Inject() private var formatter: NameFormatterType\\n    \\n    let name: String\\n    \\n    // And in any part of the struct code we can use the injected dependency\\n    func present() {\\n        print(\\\"Hi, I am \\\\(formatter.format(name: name))\\\")\\n    }\\n}\\n\\nlet fernando = Person(name: \\\"Fernando\\\")\\nfernando.present() // Will print: \\\"Hi, I am Sir Fernando\\\"\\n\")), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, \"Conclusion\"), mdx(\"p\", null, \"Dependency injection is a pattern that you will be using once and once again as a software designer. Normally, using just constructor-based DI will be enough. But having this simple alternative can be handy. Also, you have learnt one thing or two about property wrappers too. \"), mdx(\"p\", null, \"Thank you!\"), mdx(\"h2\", {\n    \"id\": \"final-code\"\n  }, \"Final Code\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-swift\"\n  }), \"enum Dependencies {\\n    struct Name: Equatable {\\n        let rawValue: String\\n        static let `default` = Name(rawValue: \\\"__default__\\\")\\n        static func == (lhs: Name, rhs: Name) -> Bool { lhs.rawValue == rhs.rawValue }\\n    }\\n    \\n    final class Container {\\n        private var dependencies: [(key: Dependencies.Name, value: Any)] = []\\n        \\n        static let `default` = Container()\\n        \\n        func register(_ dependency: Any, for key: Dependencies.Name = .default) {\\n            dependencies.append((key: key, value: dependency))\\n        }\\n        \\n        func resolve<T>(_ key: Dependencies.Name = .default) -> T {\\n            return (dependencies\\n                .filter { (dependencyTuple) -> Bool in\\n                    return dependencyTuple.key == key\\n                        && dependencyTuple.value is T\\n                }\\n                .first)?.value as! T\\n        }\\n    }\\n    \\n    @propertyWrapper\\n    struct Inject<T> {\\n        private let dependencyName: Name\\n        private let container: Container\\n        var wrappedValue: T {\\n            get { container.resolve(dependencyName) }\\n        }\\n        init(_ dependencyName: Name = .default, on container: Container = .default) {\\n            self.dependencyName = dependencyName\\n            self.container = container\\n        }\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/0002-dependency-injection-using-property-wrappers/","title":"Simple Dependency Injection using @propertyWrapper","tags":[],"keywords":[],"date":"November 02, 2019"},"previous":{"__typename":"MdxBlogPost","id":"0d6d91e4-12f0-5594-8b9f-37f1ec4d5020","excerpt":"I've been an iOS developer for almost five years. And working as a software engineer, you may know, is something frustrating. \nSure, it'sâ€¦","slug":"/0001-single-source-of-truth/","title":"A single source of truth","date":"October 26, 2019"},"next":null},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"0eeeceff-91ee-5b9d-88b3-e537a600a404","previousId":"0d6d91e4-12f0-5594-8b9f-37f1ec4d5020"}}}